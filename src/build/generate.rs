use crate::build_util::*;
use crate::config::Config;
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{Result, Write};

#[cfg(not(test))]
use crate::config::*;
#[cfg(test)]
use connate::config::*;

/// Like write!() but with an extra field that indents by 4x that many spaces.
macro_rules! iwrite {
    ($writer:expr, $level:expr, $($args:tt)*) => {
        write!($writer, "{}{}", "    ".repeat($level), format!($($args)*))
    };
}

/// Like writeln!() but with an extra field that indents by 4x that many spaces.
macro_rules! iwriteln {
    ($writer:expr, $level:expr, $($args:tt)*) => {
        writeln!($writer, "{}{}", "    ".repeat($level), format!($($args)*))
    };
}

/// Trait providing compile-time configuration code generation methods.
///
/// This trait extends `Config` and provides default implementations for generating
/// internal configuration code. This is particularly useful for testing, as test
/// configurations can implement `Config` and use these generation methods.
pub trait GenerateInternalConfig: Config {
    fn generate_internal_config(mut f: File) -> Result<()>
    where
        Self: Sized,
    {
        let uid_map = get_uid_map();
        let gid_map = get_gid_map();
        let svc_map = get_svc_map(Self::SERVICES);
        let svc_i_map = get_svc_index_map(Self::SERVICES);

        Self::generate_header(&mut f)?;
        Self::generate_lock_file(&mut f)?;
        Self::generate_service_count(&mut f)?;
        Self::generate_services_array(&mut f)?;
        Self::generate_services_methods(&mut f)?;

        // Service fields may have raw pointers to C strings.  Rust forgets to include these
        // in the binary if we define them inline with `.as_ptr()`.  Thus, we must define the C
        // strings as constants, then later `.as_ptr()` them.
        for (i, svc) in Self::SERVICES.iter().enumerate() {
            writeln!(f)?;
            svc.generate_env_cstr(&mut f, i)?;
            svc.generate_setup_cstr(&mut f, i)?;
            svc.generate_run_cstr(&mut f, i)?;
            svc.generate_cleanup_cstr(&mut f, i)?;
        }

        // Generate the service configuration definitions
        for (i, svc) in Self::SERVICES.iter().enumerate() {
            writeln!(f)?;
            writeln!(f, "const SERVICE{i}: ServiceConfig = ServiceConfig {{")?;
            svc.generate_name(&mut f)?;
            svc.generate_index(&mut f, i)?;
            svc.generate_init_target(&mut f)?;
            //
            // Dependency entries
            //
            svc.generate_needs(&mut f, &svc_i_map)?;
            svc.generate_wants(&mut f, &svc_i_map)?;
            svc.generate_conflicts(&mut f, &svc_i_map)?;
            svc.generate_stop_dependencies(&mut f, &svc_i_map, &svc_map)?;
            svc.generate_groups(&mut f, &svc_i_map)?;
            svc.generate_target_up_propagate_up(&mut f, &svc_i_map, &svc_map)?;
            svc.generate_target_up_propagate_down(&mut f, &svc_i_map, &svc_map)?;
            svc.generate_target_down_propagate_down(&mut f, &svc_i_map, &svc_map)?;
            svc.generate_propagate_dirty(&mut f, &svc_i_map, &svc_map)?;
            //
            // Execution entries
            //
            svc.generate_setup(&mut f, i)?;
            svc.generate_run(&mut f, i)?;
            svc.generate_ready(&mut f)?;
            svc.generate_cleanup(&mut f, i)?;
            svc.generate_stop_all_children(&mut f)?;
            //
            // Retry and timeout entries
            //
            svc.generate_max_setup_time_millis(&mut f)?;
            svc.generate_max_ready_time_millis(&mut f)?;
            svc.generate_max_stop_time_millis(&mut f)?;
            svc.generate_max_cleanup_time_millis(&mut f)?;
            svc.generate_retry_wait_period_millis(&mut f)?;
            svc.generate_retry_wait_multiplier(&mut f)?;
            svc.generate_max_attempt_count(&mut f)?;
            //
            // Execution attribute entries
            //
            svc.generate_log(&mut f, &svc_i_map)?;
            svc.generate_is_logger(&mut f, &svc_map)?;
            svc.generate_uid(&mut f, &uid_map)?;
            svc.generate_gid(&mut f, &gid_map)?;
            svc.generate_no_new_privs(&mut f)?;
            svc.generate_chdir(&mut f)?;
            writeln!(f, "}};")?;
        }

        Ok(())
    }

    fn generate_header(f: &mut File) -> Result<()> {
        writeln!(
            f,
            r#"// This file is generated by `src/build/main.rs`. Do not edit manually.

use connate::internal_api::*;
use core::ffi::CStr;"#
        )
    }

    fn generate_lock_file(f: &mut File) -> Result<()> {
        writeln!(f)?;
        write!(f, "pub const CONFIG_LOCK_FILE: Option<&CStr> = ")?;
        match Self::LOCK_FILE {
            Some(path) => writeln!(f, "Some(c{:?});", path),
            None => writeln!(f, "None;"),
        }
    }

    fn generate_service_count(f: &mut File) -> Result<()> {
        writeln!(f)?;
        writeln!(
            f,
            "pub const SERVICE_COUNT: usize = {};",
            Self::SERVICES.len()
        )
    }

    fn generate_services_array(f: &mut File) -> Result<()> {
        writeln!(
            f,
            r#"
/// Rust technique to store something in the .bss
///
/// The Rust borrow checker cannot enforce the mutability XOR aliasing constraint with
/// `static mut`s. Any violation is immediately undefined behavior, even if it is never accessed.
///
/// Normally the best solution is to just avoid `static mut`s.  However, this project:
///
/// - Does not use the heap at all
/// - Avoids storing potentially large variables on the stack
///
/// which just leaves .bss and .data, i.e. static mut.
///
/// We resolve this by requiring the method that the user only make a `&mut` reference to the
/// data very early on in the program life (e..g. main) and hold it for the life of the program.
struct SyncUnsafeCell<T>(core::cell::UnsafeCell<T>);

/// Safety: the caller must make a `&mut` reference to SyncUnsafeCell (e.g. in main) early in the
/// life of the program and hold it for the life of the program.
unsafe impl<T> Sync for SyncUnsafeCell<T> {{}}

/// Create static array of services in the .bss
pub struct StaticServices {{
    inner: SyncUnsafeCell<core::mem::MaybeUninit<[Service; SERVICE_COUNT]>>,
}}
pub static SERVICES: StaticServices = StaticServices {{
    inner: SyncUnsafeCell(core::cell::UnsafeCell::new(core::mem::MaybeUninit::uninit())),
}};

impl StaticServices {{
    /// Initialize the services array and return a mutable reference to it.
    ///
    /// # Safety
    ///
    /// This method must be called exactly once during program initialization.
    /// Calling it multiple times will create multiple mutable references to the
    /// same data, violating Rust's aliasing rules and causing undefined behavior.
    ///
    /// Additionally, this method assumes that the inner storage has not been accessed
    /// or modified through any other means, and that calling this function establishes
    /// the initial state of the services array for the lifetime of the program.
    pub const unsafe fn initialize(
        &self,
        now: connate::types::timespec,
    ) -> &'static mut [Service; SERVICE_COUNT] {{
        unsafe {{
            let ptr = self.inner.0.get();
            let services_uninit = &mut *ptr;
            let services = services_uninit.as_mut_ptr();
"#
        )?;
        for (i, svc) in Self::SERVICES.iter().enumerate() {
            iwriteln!(f, 3, "(*services)[{}] = Service {{", i)?;
            iwriteln!(f, 4, "state: connate::internal_api::State::Down,")?;
            iwrite!(f, 4, "target: connate::internal_api::Target::")?;
            match svc.init_target {
                Target::Down => writeln!(f, "Down,")?,
                Target::Up => writeln!(f, "Up,")?,
                Target::Restart => writeln!(f, "Restart,")?,
                Target::Once => writeln!(f, "Once,")?,
            }
            iwriteln!(f, 4, "pid: None,")?;
            iwriteln!(f, 4, "supervisor_pid: None,")?;
            iwriteln!(f, 4, "stdin_pipe: None,")?;
            iwriteln!(f, 4, "attempt_count: 0,")?;
            iwriteln!(f, 4, "exit_code: None,")?;
            iwriteln!(f, 4, "time: now,")?;
            iwriteln!(f, 4, "ready: false,")?;
            iwriteln!(f, 4, "dirty: true,")?;
            #[cfg(feature = "settle")]
            iwriteln!(f, 4, "settle_pipe: None,")?;
            iwriteln!(f, 4, "cfg: &SERVICE{},", i)?;
            iwriteln!(f, 3, "}};")?;
        }

        writeln!(
            f,
            r#"
           services_uninit.assume_init_mut()
       }}
   }}
}}"#
        )
    }

    fn generate_services_methods(f: &mut File) -> Result<()> {
        writeln!(
            f,
            r#"
/// Methods to find service leveraging compile-time knowledge of service names
///
/// At the time of writing, compiles down to a decision tree that is faster than O(n) search across
/// array of services.
pub trait ServiceArrayFind {{
    fn find_by_name(&self, name: &[u8]) -> Option<&Service>;
    fn find_by_name_mut(&mut self, name: &[u8]) -> Option<&mut Service>;
}}

impl<const N: usize> ServiceArrayFind for [Service; N] {{
    fn find_by_name(&self, name: &[u8]) -> Option<&Service> {{
        match name {{"#
        )?;

        for (i, svc) in Self::SERVICES.iter().enumerate() {
            iwriteln!(f, 3, "b{:?} => Some(&self[{i}]),", svc.name)?;
        }

        writeln!(
            f,
            r#"            _ => None,
        }}
    }}

    fn find_by_name_mut(&mut self, name: &[u8]) -> Option<&mut Service> {{
        match name {{"#
        )?;

        for (i, svc) in Self::SERVICES.iter().enumerate() {
            iwriteln!(f, 3, "b{:?} => Some(&mut self[{i}]),", svc.name)?;
        }

        writeln!(
            f,
            r#"            _ => None,
        }}
    }}
}}"#
        )
    }
}

impl Service {
    fn generate_env_cstr(&self, f: &mut File, i: usize) -> Result<()> {
        let needs_env = matches!(self.setup, Run::Exec(_) | Run::Shell(_))
            || matches!(self.run, Run::Exec(_) | Run::Shell(_))
            || matches!(self.cleanup, Run::Exec(_) | Run::Shell(_));

        if !needs_env {
            return Ok(());
        }

        for (j, var) in self.env.iter().enumerate() {
            writeln!(f, "const SERVICE{i}_ENV{j}: &CStr = c{var:?};")?;
        }
        Ok(())
    }

    fn generate_setup_cstr(&self, f: &mut File, i: usize) -> Result<()> {
        match self.setup {
            Run::None => {}
            Run::Exec(args) => {
                // Generate execve() arguments:
                // - pathname
                // - argv
                // - envp

                // pathname
                writeln!(
                    f,
                    "const SERVICE{i}_SETUP_PATHNAME: &CStr = c{:?};",
                    args[0]
                )?;

                // argv
                for (j, arg) in args.iter().enumerate() {
                    writeln!(f, "const SERVICE{i}_SETUP_ARG{j}: &CStr = c{arg:?};",)?;
                }
                let args_count = args.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_SETUP_ARGV: [*const core::ffi::c_char; {args_count}] = ["
                )?;
                for j in 0..args.len() {
                    writeln!(f, "    SERVICE{i}_SETUP_ARG{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;

                // envp
                let envp_count = self.env.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_SETUP_ENVP: [*const core::ffi::c_char; {envp_count}] = ["
                )?;
                for j in 0..self.env.len() {
                    writeln!(f, "    SERVICE{i}_ENV{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;
            }
            Run::Shell(cmd) => {
                // Generate execve() arguments:
                // - pathname
                // - argv
                // - envp

                // pathname
                writeln!(f, "const SERVICE{i}_SETUP_PATHNAME: &CStr = c\"/bin/sh\";",)?;

                // argv
                writeln!(f, "const SERVICE{i}_SETUP_ARG0: &CStr = c\"/bin/sh\";")?;
                writeln!(f, "const SERVICE{i}_SETUP_ARG1: &CStr = c\"-c\";")?;
                writeln!(f, "const SERVICE{i}_SETUP_ARG2: &CStr = c{cmd:?};")?;
                writeln!(
                    f,
                    "const SERVICE{i}_SETUP_ARGV: [*const core::ffi::c_char; 4] = ["
                )?;
                writeln!(f, "    SERVICE{i}_SETUP_ARG0.as_ptr(),")?;
                writeln!(f, "    SERVICE{i}_SETUP_ARG1.as_ptr(),")?;
                writeln!(f, "    SERVICE{i}_SETUP_ARG2.as_ptr(),")?;
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;

                // envp
                let envp_count = self.env.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_SETUP_ENVP: [*const core::ffi::c_char; {envp_count}] = ["
                )?;
                for j in 0..self.env.len() {
                    writeln!(f, "    SERVICE{i}_ENV{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;
            }
            Run::Fn(_) => {}
        }
        Ok(())
    }

    fn generate_run_cstr(&self, f: &mut File, i: usize) -> Result<()> {
        match self.run {
            Run::None => {}
            Run::Exec(args) => {
                // Generate execve() arguments:
                // - pathname
                // - argv
                // - envp

                // pathname
                writeln!(f, "const SERVICE{i}_RUN_PATHNAME: &CStr = c{:?};", args[0])?;

                // argv
                for (j, arg) in args.iter().enumerate() {
                    writeln!(f, "const SERVICE{i}_RUN_ARG{j}: &CStr = c{arg:?};",)?;
                }
                let args_count = args.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_RUN_ARGV: [*const core::ffi::c_char; {args_count}] = ["
                )?;
                for j in 0..args.len() {
                    writeln!(f, "    SERVICE{i}_RUN_ARG{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;

                // envp
                let envp_count = self.env.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_RUN_ENVP: [*const core::ffi::c_char; {envp_count}] = ["
                )?;
                for j in 0..self.env.len() {
                    writeln!(f, "    SERVICE{i}_ENV{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;
            }
            Run::Shell(cmd) => {
                // Generate execve() arguments:
                // - pathname
                // - argv
                // - envp

                // pathname
                writeln!(f, "const SERVICE{i}_RUN_PATHNAME: &CStr = c\"/bin/sh\";",)?;

                // argv
                writeln!(f, "const SERVICE{i}_RUN_ARG0: &CStr = c\"/bin/sh\";")?;
                writeln!(f, "const SERVICE{i}_RUN_ARG1: &CStr = c\"-c\";")?;
                writeln!(f, "const SERVICE{i}_RUN_ARG2: &CStr = c{cmd:?};")?;
                writeln!(
                    f,
                    "const SERVICE{i}_RUN_ARGV: [*const core::ffi::c_char; 4] = ["
                )?;
                writeln!(f, "    SERVICE{i}_RUN_ARG0.as_ptr(),")?;
                writeln!(f, "    SERVICE{i}_RUN_ARG1.as_ptr(),")?;
                writeln!(f, "    SERVICE{i}_RUN_ARG2.as_ptr(),")?;
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;

                // envp
                let envp_count = self.env.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_RUN_ENVP: [*const core::ffi::c_char; {envp_count}] = ["
                )?;
                for j in 0..self.env.len() {
                    writeln!(f, "    SERVICE{i}_ENV{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;
            }
            Run::Fn(_) => {}
        }
        Ok(())
    }

    fn generate_cleanup_cstr(&self, f: &mut File, i: usize) -> Result<()> {
        match self.cleanup {
            Run::None => {}
            Run::Exec(args) => {
                // Generate execve() arguments:
                // - pathname
                // - argv
                // - envp

                // pathname
                writeln!(
                    f,
                    "const SERVICE{i}_CLEANUP_PATHNAME: &CStr = c{:?};",
                    args[0]
                )?;

                // argv
                for (j, arg) in args.iter().enumerate() {
                    writeln!(f, "const SERVICE{i}_CLEANUP_ARG{j}: &CStr = c{arg:?};",)?;
                }
                let args_count = args.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_CLEANUP_ARGV: [*const core::ffi::c_char; {args_count}] = ["
                )?;
                for j in 0..args.len() {
                    writeln!(f, "    SERVICE{i}_CLEANUP_ARG{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;

                // envp
                let envp_count = self.env.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_CLEANUP_ENVP: [*const core::ffi::c_char; {envp_count}] = ["
                )?;
                for j in 0..self.env.len() {
                    writeln!(f, "    SERVICE{i}_ENV{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;
            }
            Run::Shell(cmd) => {
                // Generate execve() arguments:
                // - pathname
                // - argv
                // - envp

                // pathname
                writeln!(
                    f,
                    "const SERVICE{i}_CLEANUP_PATHNAME: &CStr = c\"/bin/sh\";",
                )?;

                // argv
                writeln!(f, "const SERVICE{i}_CLEANUP_ARG0: &CStr = c\"/bin/sh\";")?;
                writeln!(f, "const SERVICE{i}_CLEANUP_ARG1: &CStr = c\"-c\";")?;
                writeln!(f, "const SERVICE{i}_CLEANUP_ARG2: &CStr = c{cmd:?};")?;
                writeln!(
                    f,
                    "const SERVICE{i}_CLEANUP_ARGV: [*const core::ffi::c_char; 4] = ["
                )?;
                writeln!(f, "    SERVICE{i}_CLEANUP_ARG0.as_ptr(),")?;
                writeln!(f, "    SERVICE{i}_CLEANUP_ARG1.as_ptr(),")?;
                writeln!(f, "    SERVICE{i}_CLEANUP_ARG2.as_ptr(),")?;
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;

                // envp
                let envp_count = self.env.len() + 1; // trailing null
                writeln!(
                    f,
                    "const SERVICE{i}_CLEANUP_ENVP: [*const core::ffi::c_char; {envp_count}] = ["
                )?;
                for j in 0..self.env.len() {
                    writeln!(f, "    SERVICE{i}_ENV{j}.as_ptr(),")?;
                }
                writeln!(f, "    core::ptr::null(),")?;
                writeln!(f, "];")?;
            }
            Run::Fn(_) => {}
        }
        Ok(())
    }

    //
    // ServiceConfig entries
    //

    fn generate_name(&self, f: &mut File) -> Result<()> {
        iwriteln!(f, 1, "name: b{:?},", self.name)
    }

    fn generate_index(&self, f: &mut File, i: usize) -> Result<()> {
        iwriteln!(f, 1, "index: {i},")
    }

    fn generate_init_target(&self, f: &mut File) -> Result<()> {
        match self.init_target {
            Target::Down => iwriteln!(f, 1, "init_target: Target::Down,"),
            Target::Up => iwriteln!(f, 1, "init_target: Target::Up,"),
            Target::Restart => iwriteln!(f, 1, "init_target: Target::Restart,"),
            Target::Once => iwriteln!(f, 1, "init_target: Target::Once,"),
        }
    }

    //
    // Dependency entries
    //

    fn generate_needs(&self, f: &mut File, svc_i_map: &HashMap<&'static str, usize>) -> Result<()> {
        if self.needs.is_empty() {
            iwriteln!(f, 1, "needs: &[],")?;
            return Ok(());
        }

        iwriteln!(f, 1, "needs: &[")?;
        for dep in self.needs {
            iwriteln!(f, 2, "{}, // {}", svc_i_map[dep], dep)?;
        }
        iwriteln!(f, 1, "],")
    }

    fn generate_wants(&self, f: &mut File, svc_i_map: &HashMap<&'static str, usize>) -> Result<()> {
        if self.wants.is_empty() {
            iwriteln!(f, 1, "wants: &[],")?;
            return Ok(());
        }

        iwriteln!(f, 1, "wants: &[")?;
        for dep in self.wants {
            iwriteln!(f, 2, "{}, // {}", svc_i_map[dep], dep)?;
        }
        iwriteln!(f, 1, "],")
    }

    fn generate_conflicts(
        &self,
        f: &mut File,
        svc_i_map: &HashMap<&'static str, usize>,
    ) -> Result<()> {
        if self.conflicts.is_empty() {
            iwriteln!(f, 1, "conflicts: &[],")?;
            return Ok(());
        }

        iwriteln!(f, 1, "conflicts: &[")?;
        for dep in self.conflicts {
            iwriteln!(f, 2, "{}, // {}", svc_i_map[dep], dep)?;
        }
        iwriteln!(f, 1, "],")
    }

    fn generate_stop_dependencies(
        &self,
        f: &mut File,
        svc_i_map: &HashMap<&'static str, usize>,
        svc_map: &HashMap<&'static str, &Service>,
    ) -> Result<()> {
        let mut deps: Vec<(usize, &str)> = Vec::new();

        // Direct reverse dependencies only (no groups, no transitivity)
        for (_, svc) in svc_map.iter() {
            if self.name == svc.name {
                continue;
            }
            // Services that need this service
            if svc.needs.contains(&self.name) {
                deps.push((svc_i_map[svc.name], svc.name));
                continue;
            }
            // Services that want this service
            if svc.wants.contains(&self.name) {
                deps.push((svc_i_map[svc.name], svc.name));
                continue;
            }
            // Services that log to this service
            if let Log::Service(log_service) = &svc.log
                && *log_service == self.name
            {
                deps.push((svc_i_map[svc.name], svc.name));
            }
        }

        deps.sort();

        if deps.is_empty() {
            iwriteln!(f, 1, "stop_dependencies: &[],")
        } else {
            iwriteln!(f, 1, "stop_dependencies: &[")?;
            for (i, name) in deps {
                iwriteln!(f, 2, "{i}, // {name}")?;
            }
            iwriteln!(f, 1, "],")
        }
    }

    fn generate_groups(
        &self,
        f: &mut File,
        svc_i_map: &HashMap<&'static str, usize>,
    ) -> Result<()> {
        if self.groups.is_empty() {
            iwriteln!(f, 1, "groups: &[],")?;
            return Ok(());
        }

        iwriteln!(f, 1, "groups: &[")?;
        for dep in self.groups {
            iwriteln!(f, 2, "{}, // {}", svc_i_map[dep], dep)?;
        }
        iwriteln!(f, 1, "],")
    }

    // When this service's target is changed to be upward, propagate that change to these other
    // services.
    //
    // This includes:
    // - groups (whose purpose is entirely about target propagation)
    // - needs (this service needs those to go up before it tries to)
    // - wants (this service wants those to go up before it tries to)
    // - logs (this service can't log to the service until it's up)
    fn generate_target_up_propagate_up(
        &self,
        f: &mut File,
        svc_i_map: &HashMap<&'static str, usize>,
        svc_map: &HashMap<&'static str, &Service>,
    ) -> Result<()> {
        let mut visited: HashSet<&'static str> = HashSet::new();
        let mut stack: Vec<&'static str> = Vec::new();

        // Start with self's direct dependencies.
        self.push_direct_target_up_propagate_up(&mut stack);

        // Traverse the dependency graph transitively.
        while let Some(dep_name) = stack.pop() {
            if visited.insert(dep_name) {
                svc_map[dep_name].push_direct_target_up_propagate_up(&mut stack);
            }
        }

        // Exclude self if present.
        visited.remove(self.name);

        // Sort the services by index to make reading and debugging the generated file easier.
        let mut indices: Vec<(usize, &str)> = visited
            .iter()
            .map(|name| (svc_i_map[name], *name))
            .collect();
        indices.sort();

        if indices.is_empty() {
            iwriteln!(f, 1, "target_up_propagate_up: &[],")
        } else {
            iwriteln!(f, 1, "target_up_propagate_up: &[")?;
            for (i, name) in indices {
                iwriteln!(f, 2, "{i}, // {name}")?;
            }
            iwriteln!(f, 1, "],")
        }
    }

    fn push_direct_target_up_propagate_up(&self, deps: &mut Vec<&str>) {
        deps.extend_from_slice(self.needs);
        deps.extend_from_slice(self.wants);
        deps.extend_from_slice(self.groups);
        if let Log::Service(log_service) = &self.log {
            deps.push(log_service);
        }
    }

    fn generate_target_up_propagate_down(
        &self,
        f: &mut File,
        svc_i_map: &HashMap<&'static str, usize>,
        svc_map: &HashMap<&'static str, &Service>,
    ) -> Result<()> {
        let mut visited: HashSet<&'static str> = HashSet::new();
        let mut stack: Vec<&'static str> = Vec::new();

        // Start with self's direct conflicts.
        stack.extend_from_slice(self.conflicts);

        // Traverse the conflict graph transitively.
        while let Some(dep_name) = stack.pop() {
            if visited.insert(dep_name) {
                svc_map[dep_name].push_direct_target_down_propagate_down(svc_map, &mut stack);
            }
        }

        // Exclude self if present.
        visited.remove(self.name);

        // Convert collected service names into their corresponding indices.
        let mut indices: Vec<(usize, &str)> = visited
            .iter()
            .map(|&name| (svc_i_map[name], name))
            .collect();
        indices.sort();

        if indices.is_empty() {
            iwriteln!(f, 1, "target_up_propagate_down: &[],")
        } else {
            iwriteln!(f, 1, "target_up_propagate_down: &[")?;
            for (i, name) in indices {
                iwriteln!(f, 2, "{i}, // {name}")?;
            }
            iwriteln!(f, 1, "],")
        }
    }

    // When this service's target is changed to be downward, propagate that change to these other
    // services.
    //
    // This includes:
    // - groups (whose purpose is entirely about target propagation)
    // - needed by
    // - wanted by
    // - logged to
    fn generate_target_down_propagate_down(
        &self,
        f: &mut File,
        svc_i_map: &HashMap<&'static str, usize>,
        svc_map: &HashMap<&'static str, &Service>,
    ) -> Result<()> {
        let mut visited: HashSet<&'static str> = HashSet::new();
        let mut stack: Vec<&'static str> = Vec::new();

        // Start with this service's direct reverse dependencies.
        self.push_direct_target_down_propagate_down(svc_map, &mut stack);

        // Traverse the reverse dependency graph transitively.
        while let Some(dep_name) = stack.pop() {
            if visited.insert(dep_name) {
                svc_map[dep_name].push_direct_target_down_propagate_down(svc_map, &mut stack);
            }
        }

        // Exclude self if present.
        visited.remove(self.name);

        // Sort the services by index to make reading and debugging the generated file easier.
        let mut indices: Vec<(usize, &str)> = visited
            .iter()
            .map(|&name| (svc_i_map[name], name))
            .collect();
        indices.sort();

        if indices.is_empty() {
            iwriteln!(f, 1, "target_down_propagate_down: &[],")
        } else {
            iwriteln!(f, 1, "target_down_propagate_down: &[")?;
            for (i, name) in indices {
                iwriteln!(f, 2, "{i}, // {name}")?;
            }
            iwriteln!(f, 1, "],")
        }
    }

    fn push_direct_target_down_propagate_down(
        &self,
        svc_map: &HashMap<&'static str, &Service>,
        deps: &mut Vec<&str>,
    ) {
        // Include any services directly listed in self.groups.
        deps.extend_from_slice(self.groups);

        // For every service in the configuration, if it depends on self via its
        // needs, wants, or log (Service variant) fields, add it as a reverse dependency.
        for (_, svc) in svc_map.iter() {
            if svc.name == self.name {
                continue;
            }
            if svc.needs.contains(&self.name) {
                deps.push(svc.name);
            }
            if svc.wants.contains(&self.name) {
                deps.push(svc.name);
            }
            if let Log::Service(log_service) = &svc.log
                && *log_service == self.name
            {
                deps.push(svc.name);
            }
        }
    }

    // When this service's state changes, other service state changes may be unblocked and should
    // be re-considered.
    fn generate_propagate_dirty(
        &self,
        f: &mut File,
        svc_i_map: &HashMap<&'static str, usize>,
        svc_map: &HashMap<&'static str, &Service>,
    ) -> Result<()> {
        let mut deps: HashSet<&str> = HashSet::new();

        deps.extend(self.needs);
        deps.extend(self.wants);
        deps.extend(self.groups);
        if let Log::Service(log_service) = &self.log {
            deps.insert(log_service);
        }

        for (_, svc) in svc_map.iter() {
            if svc.needs.contains(&self.name) {
                deps.insert(svc.name);
                continue;
            }
            if svc.wants.contains(&self.name) {
                deps.insert(svc.name);
                continue;
            }
            if svc.conflicts.contains(&self.name) {
                deps.insert(svc.name);
                continue;
            }
            if let Log::Service(log_service) = &svc.log
                && *log_service == self.name
            {
                deps.insert(svc.name);
            }
        }

        let mut deps = deps
            .into_iter()
            .map(|name| (svc_i_map[name], name))
            .collect::<Vec<_>>();
        deps.sort();

        if deps.is_empty() {
            iwriteln!(f, 1, "propagate_dirty: &[],")
        } else {
            iwriteln!(f, 1, "propagate_dirty: &[")?;
            for (i, name) in deps {
                iwriteln!(f, 2, "{i}, // {name}")?;
            }
            iwriteln!(f, 1, "],")
        }
    }

    //
    // Retry and timeout entries
    //

    fn generate_max_setup_time_millis(&self, f: &mut File) -> Result<()> {
        let max = self.max_setup_time.map(|dur| dur.as_millis() as i32);
        iwriteln!(f, 1, "max_setup_time_millis: {:?},", max)
    }

    fn generate_max_ready_time_millis(&self, f: &mut File) -> Result<()> {
        let max = self.max_ready_time.map(|dur| dur.as_millis() as i32);
        iwriteln!(f, 1, "max_ready_time_millis: {:?},", max)
    }

    fn generate_max_stop_time_millis(&self, f: &mut File) -> Result<()> {
        let max = self.max_stop_time.map(|dur| dur.as_millis() as i32);
        iwriteln!(f, 1, "max_stop_time_millis: {:?},", max)
    }

    fn generate_max_cleanup_time_millis(&self, f: &mut File) -> Result<()> {
        let max = self.max_cleanup_time.map(|dur| dur.as_millis() as i32);
        iwriteln!(f, 1, "max_cleanup_time_millis: {:?},", max)
    }

    fn generate_retry_wait_period_millis(&self, f: &mut File) -> Result<()> {
        let delay = match self.retry {
            Retry::Never => 0, // Doesn't matter, value is effectively ignored
            Retry::AfterFixed { after, .. } => after.as_millis() as i32,
            Retry::AfterDoublingDelay { initial_delay, .. } => initial_delay.as_millis() as i32,
        };
        iwriteln!(f, 1, "retry_wait_period_millis: {},", delay)
    }

    fn generate_retry_wait_multiplier(&self, f: &mut File) -> Result<()> {
        let multiplier = match self.retry {
            Retry::Never => 0, // Doesn't matter, value is effectively ignored
            Retry::AfterFixed { .. } => 1,
            Retry::AfterDoublingDelay { .. } => 2,
        };
        iwriteln!(f, 1, "retry_wait_multiplier: {},", multiplier)
    }

    fn generate_max_attempt_count(&self, f: &mut File) -> Result<()> {
        let max = match self.retry {
            Retry::Never => Some(0),
            Retry::AfterFixed {
                max_attempt_count, ..
            } => max_attempt_count,
            Retry::AfterDoublingDelay {
                max_attempt_count, ..
            } => max_attempt_count,
        };
        iwriteln!(f, 1, "max_attempt_count: {:?},", max)
    }

    //
    // Execution entries
    //

    fn generate_setup(&self, f: &mut File, i: usize) -> Result<()> {
        match self.setup {
            Run::None => iwriteln!(f, 1, "setup: Run::None,"),
            Run::Exec(_) | Run::Shell(_) => {
                iwriteln!(f, 1, "setup: Run::Exec {{")?;
                iwriteln!(f, 2, "pathname: SERVICE{i}_SETUP_PATHNAME,")?;
                iwriteln!(f, 2, "argv: SERVICE{i}_SETUP_ARGV.as_ptr(),")?;
                iwriteln!(f, 2, "envp: SERVICE{i}_SETUP_ENVP.as_ptr(),")?;
                let overwrite = matches!(
                    self.log,
                    Log::File {
                        mode: FileMode::Overwrite,
                        ..
                    }
                );
                iwriteln!(f, 2, "log_overwrite: {overwrite},")?;
                iwriteln!(f, 1, "}},")
            }
            Run::Fn(_) => {
                iwriteln!(f, 1, "setup: Run::Fn {{")?;
                iwriteln!(
                    f,
                    2,
                    "f: match <connate::config::Connate as connate::config::Config>::SERVICES[{}].setup {{ connate::config::Run::Fn(f) => f, _ => unreachable!() }},",
                    i
                )?;
                let overwrite = matches!(
                    self.log,
                    Log::File {
                        mode: FileMode::Overwrite,
                        ..
                    }
                );
                iwriteln!(f, 2, "log_overwrite: {overwrite},")?;
                iwriteln!(f, 1, "}},")
            }
        }
    }

    fn generate_run(&self, f: &mut File, i: usize) -> Result<()> {
        match self.run {
            Run::None => iwriteln!(f, 1, "run: Run::None,"),
            Run::Exec(_) | Run::Shell(_) => {
                iwriteln!(f, 1, "run: Run::Exec {{")?;
                iwriteln!(f, 2, "pathname: SERVICE{i}_RUN_PATHNAME,")?;
                iwriteln!(f, 2, "argv: SERVICE{i}_RUN_ARGV.as_ptr(),")?;
                iwriteln!(f, 2, "envp: SERVICE{i}_RUN_ENVP.as_ptr(),")?;
                let overwrite = matches!(
                    self.log,
                    Log::File {
                        mode: FileMode::Overwrite,
                        ..
                    }
                ) && matches!(self.setup, Run::None);
                iwriteln!(f, 2, "log_overwrite: {overwrite},")?;
                iwriteln!(f, 1, "}},")
            }
            Run::Fn(_) => {
                iwriteln!(f, 1, "run: Run::Fn {{")?;
                iwriteln!(
                    f,
                    2,
                    "f: match <connate::config::Connate as connate::config::Config>::SERVICES[{}].run {{ connate::config::Run::Fn(f) => f, _ => unreachable!() }},",
                    i
                )?;
                let overwrite = matches!(
                    self.log,
                    Log::File {
                        mode: FileMode::Overwrite,
                        ..
                    }
                ) && matches!(self.setup, Run::None);
                iwriteln!(f, 2, "log_overwrite: {overwrite},")?;
                iwriteln!(f, 1, "}},")
            }
        }
    }

    fn generate_ready(&self, f: &mut File) -> Result<()> {
        match self.ready {
            Ready::Immediately => iwriteln!(f, 1, "ready: Ready::Immediately,"),
            Ready::Notify => iwriteln!(f, 1, "ready: Ready::Notify,"),
            Ready::Daemonize => iwriteln!(f, 1, "ready: Ready::Daemonize,"),
        }
    }

    fn generate_cleanup(&self, f: &mut File, i: usize) -> Result<()> {
        match self.cleanup {
            Run::None => iwriteln!(f, 1, "cleanup: Run::None,"),
            Run::Exec(_) | Run::Shell(_) => {
                iwriteln!(f, 1, "cleanup: Run::Exec {{")?;
                iwriteln!(f, 2, "pathname: SERVICE{i}_CLEANUP_PATHNAME,")?;
                iwriteln!(f, 2, "argv: SERVICE{i}_CLEANUP_ARGV.as_ptr(),")?;
                iwriteln!(f, 2, "envp: SERVICE{i}_CLEANUP_ENVP.as_ptr(),")?;
                let overwrite = matches!(
                    self.log,
                    Log::File {
                        mode: FileMode::Overwrite,
                        ..
                    }
                ) && matches!(self.setup, Run::None)
                    && matches!(self.run, Run::None);
                iwriteln!(f, 2, "log_overwrite: {overwrite},")?;
                iwriteln!(f, 1, "}},")
            }
            Run::Fn(_) => {
                iwriteln!(f, 1, "cleanup: Run::Fn {{")?;
                iwriteln!(
                    f,
                    2,
                    "f: match <connate::config::Connate as connate::config::Config>::SERVICES[{}].cleanup {{ connate::config::Run::Fn(f) => f, _ => unreachable!() }},",
                    i
                )?;
                let overwrite = matches!(
                    self.log,
                    Log::File {
                        mode: FileMode::Overwrite,
                        ..
                    }
                ) && matches!(self.setup, Run::None)
                    && matches!(self.run, Run::None);
                iwriteln!(f, 2, "log_overwrite: {overwrite},")?;
                iwriteln!(f, 1, "}},")
            }
        }
    }

    fn generate_stop_all_children(&self, f: &mut File) -> Result<()> {
        iwriteln!(f, 1, "stop_all_children: {},", self.stop_all_children)
    }

    //
    // Execution attribute entries
    //

    fn generate_log(&self, f: &mut File, svc_i_map: &HashMap<&'static str, usize>) -> Result<()> {
        iwrite!(f, 1, "log: ")?;
        match &self.log {
            Log::None => writeln!(f, "Log::None,")?,
            Log::Inherit => writeln!(f, "Log::Inherit,")?,
            Log::File {
                path,
                mode: _,
                permissions,
            } => {
                writeln!(f, "Log::File {{")?;
                iwriteln!(f, 3, "filepath: c{path:?},")?;
                match permissions {
                    FilePerm::Public => {
                        iwriteln!(f, 3, "mode: 0o644,")?;
                    }
                    FilePerm::Private => {
                        iwriteln!(f, 3, "mode: 0o600,")?;
                    }
                };
                iwriteln!(f, 2, "}},")?;
            }
            Log::Service(service_name) => writeln!(
                f,
                "Log::Service({}), // {}",
                svc_i_map[service_name], service_name
            )?,
        };

        Ok(())
    }

    fn generate_is_logger(
        &self,
        f: &mut File,
        svc_map: &HashMap<&'static str, &Service>,
    ) -> Result<()> {
        let is_logger = svc_map
            .values()
            .any(|s| matches!(&s.log, Log::Service(logger_name) if *logger_name == self.name));
        iwriteln!(f, 1, "is_logger: {},", is_logger)
    }

    fn generate_uid(&self, f: &mut File, uid_map: &HashMap<String, u32>) -> Result<()> {
        match self.user {
            Some(user) => iwriteln!(f, 1, "uid: Some({}),", uid_map[user]),
            None => iwriteln!(f, 1, "uid: None,"),
        }
    }

    fn generate_gid(&self, f: &mut File, gid_map: &HashMap<String, u32>) -> Result<()> {
        match self.group {
            Some(group) => iwriteln!(f, 1, "gid: Some({}),", gid_map[group]),
            None => iwriteln!(f, 1, "gid: None,"),
        }
    }

    fn generate_no_new_privs(&self, f: &mut File) -> Result<()> {
        iwriteln!(f, 1, "no_new_privs: {},", self.no_new_privs)
    }

    fn generate_chdir(&self, f: &mut File) -> Result<()> {
        match self.chdir {
            Some(path) => iwriteln!(f, 1, "chdir: Some(c{:?}),", path),
            None => iwriteln!(f, 1, "chdir: None,"),
        }
    }
}
